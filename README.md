# Machine_dependent_programming_languages
Learning course at 4th semester of BMSTU (2019)

## Lab 1
Изучение отладчика AFD
## Lab 2
Отладка в CV (CodeView)
## Lab 3
Работа в CV, анализ кода предоставленной программы
## Lab 4
Задача 1
Составить программу из двух модулей. Модуль lr04-1-1.asm содержит описание стека, сегмента данных с переменной X db `R`  и сегмент кода с точкой входа. lr04-1-1.asm управление передаётся в lr05-1-2.asm (в программе должен быть один сегмент кода), где выполняется вывод в видеопамять значения из X в 3-ю строку и 2-й столбец и выход из ПОДпрограммы по RET. Видеопамять должен представлять сегмент DS2 второго модуля, используя директивы ORG и LABEL поместите в его начало переменную CA типа BYTE со значением '0', а во второе знакоместо в третьей строке – переменную Z типа WORD. Для заполнения Z использовать AX, поместив в AL значение X, а в AH - число 10 (формат вывода). 

Задача 2
Составить программу из двух модулей. Модули lr04-2-1.asm и lr04-2-2.asm должны иметь описание сегмента памяти SD1, начинающееся с одного и того же параграфа ОП. В SD1 модуля lr04-2-1.asm должно быть объявлено слово W с начальным значением 3444h, а в SD1 модуля lr05-2-2asm должны быть объявлены байтовые переменные C1 и C2. Сегмент кода должен быть объявлен только во втором модуле. Программа должна выводить значения  C1 и C2 в виде символов.

Задача 3
Составить одномодульную программу lr04-3-1.asm, содержащую только один сегмент кода и три сегмента данных SD1, SD2, SD3. Сегменты данных должны иметь длины 64К-2 и описания байтовых переменных S1, S2, S3 с начальными значениями. Эти значения вывести в виде символов последовательно, начиная с новых строк. 

Задача 4
Составить программу из двух исходных модулей. Модуль 1 должен содержать описания сегмента стека SSTK, сегмента данных SD1 (с переменной X    DB   'X')  и часть описания сегмента кода SC1. Модуль 2 должен содержать описание сегмента данных SD2 (с переменной Y   DB   'Y') и другую часть описания кода в сегменте SC2. 
Управление должен получить Модуль 1 и сразу передать управление в Модуль 2 командой JMP. 
В Модуле 2 следует поменять значения переменных X и Y, вывести значение переменной Y (т.е. символ 'X') по функции 2 DOS и выйти из программы по функции 4Ch команды INT 21h.

## Lab 5
Составить программу транспонирования матрицы Y(5*5). Использовать способ адресации, предложенный преподавателем (все)

## Lab 6
Составить программу, выполняющую в цикле, работы, соответствующие вводимому символу:
‘0’ – вывод пунктов меню с номерами 0..8
‘1’ – ввод (в основной программе, без проверки корректность ввода) с клавиатуры десятичного целого, возможно, со знаком минус, преобразование во внутреннее представление в функции, возвращающей результат типа int (16), и размещение (в основной программе) в 2-байтовой ячейке X.
‘2’ –  вывод на экран с новой строки значения из ячейки Х в форме двоичного целого без знака и без лидирующих нулей (использовать команды сдвига).
‘3’ – вывод на экран с новой строки значения из ячейки Х в форме двоичного целого со знаком и без лидирующих нулей (использовать команду NEG и процедуру предыдущего пункта).
‘4’ – вывод на экран с новой строки значения из ячейки Х в форме десятичного целого без знака (использовать команду деления).
‘5’ – вывод на экран с новой строки значения из ячейки Х в форме десятичного целого со знаком (использовать команду NEG и процедуру предыдущего пункта).
‘6’ – вывод на экран с новой строки значения из ячейки Х в форме шестнадцатеричного целого без знака (использовать команды циклического сдвига и конъюнкции).
‘7’ – вывод на экран с новой строки значения из ячейки Х в форме шестнадцатеричного целого со знаком (использовать команду NEG и процедуру предыдущего пункта).
‘8’ – завершение работы программы.
Для перехода на новую строку экрана составить и использовать процедуру.
ДЛЯ ВЫЗОВА ВСЕХ ПРОЦЕДУР 2..7 В ОСНОВНОЙ ПРОГРАММЕ,  ИСПОЛЬЗОВАТЬ ОДНУ КОМАНДУ CALL И КОСВЕННУЮ АДРЕСАЦИЮ ПО ПАМЯТИ.
ДЛЯ ВСЕХ ПРОЦЕДУР ИСПОЛЬЗОВАТЬ СОГЛАШЕНИЯ Turbo Pascal ПО СВЯЗЫВАНИЮ ПОДПРОГРАММ.
Все процедуры должны быть ближними и располагаться в отдельных модулях.

Сделать работающую программу с подпрограммами-заглушками по пунктам 2, 3,…7 и защитить

## Lab 7
Составить программу, выполняющую в цикле, работы, соответствующие вводимому символу:
‘0’ – вывод пунктов меню с номерами 0..8
‘1’ – ввод (в основной программе, без проверки корректность ввода) с клавиатуры десятичного целого, возможно, со знаком минус, преобразование во внутреннее представление в функции, возвращающей результат типа int (16), и размещение (в основной программе) в 2-байтовой ячейке X.
‘2’ –  вывод на экран с новой строки значения из ячейки Х в форме двоичного целого без знака и без лидирующих нулей (использовать команды сдвига).
‘3’ – вывод на экран с новой строки значения из ячейки Х в форме двоичного целого со знаком и без лидирующих нулей (использовать команду NEG и процедуру предыдущего пункта).
‘4’ – вывод на экран с новой строки значения из ячейки Х в форме десятичного целого без знака (использовать команду деления).
‘5’ – вывод на экран с новой строки значения из ячейки Х в форме десятичного целого со знаком (использовать команду NEG и процедуру предыдущего пункта).
‘6’ – вывод на экран с новой строки значения из ячейки Х в форме шестнадцатеричного целого без знака (использовать команды циклического сдвига и конъюнкции).
‘7’ – вывод на экран с новой строки значения из ячейки Х в форме шестнадцатеричного целого со знаком (использовать команду NEG и процедуру предыдущего пункта).
‘8’ – завершение работы программы.
Для перехода на новую строку экрана составить и использовать процедуру.
ДЛЯ ВЫЗОВА ВСЕХ ПРОЦЕДУР 2..7 В ОСНОВНОЙ ПРОГРАММЕ,  ИСПОЛЬЗОВАТЬ ОДНУ КОМАНДУ CALL И КОСВЕННУЮ АДРЕСАЦИЮ ПО ПАМЯТИ.
ДЛЯ ВСЕХ ПРОЦЕДУР ИСПОЛЬЗОВАТЬ СОГЛАШЕНИЯ Turbo Pascal ПО СВЯЗЫВАНИЮ ПОДПРОГРАММ.
Все процедуры должны быть ближними и располагаться в отдельных модулях.

Отладить работу подпрограмм вывода (пункты меню 2-7) и защитить

## Lab 8
Транспонирование матрицы со вставкой ассемблерного кода в си. Сравнение памяти. 

## Lab 9
Нахождение факториал числа

## Lab 10
СОСТАВИТЬ КОНСОЛЬНУЮ ПРОГРАММУ VS C++, ВЫЗЫВАЮЩУЮ РАСПОЛОЖЕННУЮ В МОДУЛЕ PP.ASM ГЛАВНУЮ АССЕМБЛЕРНУЮ ПРОЦЕДУРУ P0 ТИПА
void P0() КОТОРАЯ ОРГАНИЗУЕТ ПРОВЕРКУ РАБОТЫ ДРУГИХ АССЕМБЛЕРНЫХ ПОДПРОГРАММ. ВСЕ ПОДПРОГРАММЫ СОСТАВИТЬ ПО СОГЛАШЕНИЯМ VS C++ В ОТДЕЛЬНЫХ ФАЙЛАХ.

1. Составить подпрограмму с именем SetCler типа
void SetCler (int *X, int N, int P=1)
выполняющую установку разряда N битовой строки S в ноль, если P=0, или в единицу,если P не задан или не равен 0.

2. Составить подпрограмму с именем Count типа
int Count(int *X, int L)
возвращающую число единиц битовой строки S длины L. 3. Составить подпрограмму с именем A_u_B типа

3. Составить подпрограмму с именем A_u_B типа
void A_u_B(int *A, int *B, int N)
выполняющую объединение битовых строк A:=A_u_B длины N.

4. Составить подпрограмму с именем A_B типа
void A_B(int *A, int *B, int N)
выполняющую объединение разности строк A:=A\B длины N.

Использовать эти подпрограммы для выполнения соответствующих работ над битовыми строками из 38 разрядов, объявленными с помощью директив DD в модуле PP.ASM.

## Lab 11
Составить консольное приложение VS C++, использующее три функции с заголовками
int DlinaStroki(char *s);
char *CopyStr(char *s1, char *s2, int L);
int DelProbel(char *s);

Функция DlinaStroki должна возвращать длину строки ASCIIZ (Си), заданную параметром s.
Функция CopyStr должна копировать последовательность из L байтов, заданную параметром s1, в область памяти, заданную параметром s2, и возвращать указатель на начало этой области.
Функция DelProbel должна удалять лидирующие и хвостовые пробелы в sc - строке Си, не менять начало строки и возвращать её новую длину.

## Lab 12

Составить макроопределения
Задание 1. swap для разных типов переменных
Задание 2. Push и pop для списка параметров
Задание 3. Прототип функции по соглашению (макрос генерации кода)
Задание 4. Подготовить текстовый файл 
